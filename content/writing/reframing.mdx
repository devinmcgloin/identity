---
title: Reframing Goals
date: '2018-01-29'
excerpt:
category: Career
tags:
  - Career
  - Goals
layout: 'post'
---

I last wrote about my goals in [Mission
Briefing](/writing/2017/mission-briefing/) back in March of 2017. It's time to
reframe that post, with more detail and view the same problems outlined there at
a lower altitude.

The goal of all software engineers is to build quality software. Quality
software does not just mean that it's bug free, but also that it's well
designed, and solves a problem in a scalable performant way. (If the software
doesn't need to scale, then you can remove that requirement.) Beyond these
attributes, quality software in the future will have to adapt to the user and
respond to the context in which it's used. While computing with context, and
flexibility is the future of computing, the best way I can impact those
movements is to become an excellent engineer in the status quo.

This is important for a multitude of reasons. Primarily, having a steeper growth
curve when you're starting out yields fantastic returns later. Imagine a scenario
in which you start off with 100 knowledge units _(I know this is silly, but the
point is to show growth in some units)_ and join a company that has a
learning rate of 6% per year. After 5 years you would have 130 knowledge
units. If the learning rate was only 12% you would be at 160 after 5 years.

| Learning Rate | Improvement After 5 Years |
| ------------- | ------------------------- |
| 6.0           | 130                       |
| 8.0           | 140                       |
| 10.0          | 150                       |
| 12.0          | 160                       |
| 14.0          | 170                       |

Now this is after a relatively small time period of 5 years. Most people retire
after ~40 years.

| Learning Rate | Improvement After 40 Years |
| ------------- | -------------------------- |
| 6.0           | 340                        |
| 8.0           | 420                        |
| 10.0          | 500                        |
| 12.0          | 580                        |
| 14.0          | 660                        |

Calculating simple interest isn't the best way to figure out how much you have
improved over a duration of time. However it's certainly the simplest and gets
the point across.

These learning rates are relatively conservative, but the point it to show how a
marginally better learning rate compounds. The question then becomes where to
best apply that learning, what technologies or models of thinking about software
are best to learn and what places are the best to learn them?

The most impactful area to focus is on the application server level. To be
clear, there is significant value add in HCI, UI/UX and interface design. There
are less limitations in how the content can be represented, and that is
incredibly freeing. However, increasingly where software meets the real world
occurs on the server. If the application makes an impact on the world it has to
manage shared state across multiple platforms and installations, as well as
perform computationally intensive tasks that the installations depend on. What
the server can and cannot do limits what is possible on the front end, and
therefore servers seem like the most likely bottleneck to making computation
contextual and adaptive.

Knowing what to build is more important than knowing how to build it. Part of
being a great engineer is understanding the context in which you are creating
your software. Understanding the context requires knowledge of the product, the
marketplace and how the product is being positioned. All of these factors inform
what tradeoffs are made, and what aspects of your design are useful abstractions
vs complications that will later hurt your ability to work with the code.
Understanding both the product and engineering sides of the equation allows an
engineer to be most effective.

Which companies and industries are most likely to have a higher learning curve?
This question seems exceedingly difficult to answer. Considering which
industries seems much simpler, accordingly that's a good place to start.

How steep your growth curve is depends primarily on how much you are challenged
and who you are working with. Challenging problems show up in almost any
industry and oftentimes engineers switch industries. One way to narrow down the
list of possible industries is to consider where engineers you respect are
working. [Papers We Love](http://paperswelove.org) has been invaluable in this
regard. As well as looking at portfolio companies for VC's that have a good
track records or interesting insightful commentary.

It is more clear what types of companies would provide the best learning
curve. Mid stage startups are grappling with technical challenges and have long
since exited the idea maze. They're growing rapidly and therefore there are
opportunities to take more responsibility. With a smaller headcount one person
can make a large difference, and see the results of their work on the product.
They are large enough to have mentor ship opportunities and established best
practices.

## Some Examples

There are loads of interesting companies out there; here are some particularly
compelling ones.

### Stripe:

[Stripe](https://stripe.com) is a payments processing company that makes
starting up and accepting payments exceptionally easy, including managing
subscriptions and marketplaces. They have services to detect fraud, register a
Delaware C Corp and ask questions of your payments data.

- **API Design**: Stripe thinks about API Design as a contract between the user and
  Stripe. They have versioned APIs which ensures that customers are never
  forced to make emergency patches when a breaking change is introduced.
  Engineering such a system isn't particularly simple, and certainly isn't
  cheap. Their choice to roll out their API in this manner shows true empathy
  for their users.
- **Impact**: Stripe recently launched [Sigma](https://stripe.com/us/sigma),
  which allows businesses to easily asses their chosen business metrics.
  To be clear, Stripe could have very easily created a
  simple dashboard with common metrics. Instead they developed a SQL compliant
  query language which allows customers to analyze their own data how they
  want to. It imposes fewer restrictions and allows customers flexibility. As
  a bonus you get the aforementioned dashboard of common metrics for free.
  Detecting fraud, and making it simple to create a C Corp are great value adds
  as well.
- **Culture**: Stripe has a strong product and growth culture. The focus is squarely
  on creating a better product and solving more problems for their customers.
  This is pervasive throughout all their products.
- **Network Effects**: Stripe doesn't just impact the people who are paying for the
  platform, it also allows more businesses to operate and charge payments in a
  much simpler and more secure manner then was possible before. Having
  different payment models (subscription, marketplace, one off payments),
  allows a company to switch their business model with very little upfront
  cost. This means more businesses are started and are more likely to succeed.

### Intercom:

[Intercom](https://intercom.com) is a platform for managing relationships
between businesses and their customers. It provides tools for having
conversations with customers, engaging them with targeted messages and
educating them on how a project works. They've recently ventured into the
chatbot space with [Operator](https://www.intercom.com/operator-bot).

- **Product Sense**: Intercom has incredibly strong sense of what to ship and
  what to hold off on. They iterate quickly to meet customer pain points, It's
  useful that they can manage that interaction within the Intercom Platform,
  and therefore dogfood their own product. They've also made a very deliberate
  choice to ship incremental features over large products. In doing so the
  products shipped are more thoughtful, grounded and immediately useful to
  customers. Intercom can also hear customer feedback during this cycle and
  shape the product to specific pain points that arise in the cycle.
- **Creating more value then it captures**: Intercom provides a tremendous service,
  Sending targeted messages and responding to questions in near real time is a
  massive value add and so much more enjoyable then traditional support
  solutions. The per customer cost for their standard tier Engage
  and Respond products with 30,000 users is **\$0.03** per user per
  month. With 1,000 users it costs **\$0.23** per user per month. That's
  exceptional value.
- **Broad mandate with precise execution**: Intercom's goal is to make internet
  business personal. This is a wide mandate, however Intercom is incredibly
  focused on crafting precise tools that solve specific problems. Their
  products are well scoped, and make a ton of sense on first read. Everything
  is built on top of their customer intelligence platform, which gives
  businesses flexibility to manage their own work flows and shape the product
  for their needs.
- **Empathy for the user**: The reason Intercom exists is to help businesses manage
  their interactions with their customers. When reading their content, or
  viewing their products this becomes immediately clear.
- **Growth Culture**: Intercom also believes strongly in having a growth mindset
  and places lots of emphasis on growing as an engineer. This directly aligns
  with my goal of finding a steep learning curve.

## Others:

As mentioned earlier, their are loads of interesting companies making fantastic
products. Hopefully I'll get around to writing about most of them.

## Providing Value

It's clear these places would be good places to work. If they are good places
to work, they must have a lot of interest from other software engineers. The
question then is what value can I provide that offsets both the cost of hiring
me and not hiring someone else?

- **Ramping Up Quickly**: Whether it's your architecture, new libraries or new
  ways to think about software, I can ramp up to being productive in a new
  environment quickly.
- **Driving to the Heart of the Problem**: I have a good sense of where a
  problem lies and what the bottle neck probably is. Honing in on what's
  important and what can be safely put on the end of the queue saves both time
  and money.
- **Strong Mental Models**: Understanding software is about understanding the
  underlying model of the computation rather than understanding what it's
  called or how to use it. I am constantly adding new mental models, and focus
  on understanding the underlying ideas and primitives at work.
- **Sense of Product & Design Trade offs**: I've spent the last few months
  building [Fokal](https://fok.al), which has given me a great sense of the
  product and design trade offs that have to be made when building real
  products.
- **Understands the fundamentals of scaling software**: I've spent time
  understanding how to scale software affordably and efficiently. I can reason
  about advantages and disadvantages of specific architectures, and understand
  how to choose an architecture based on the workload.
- **Deep understanding of data structures and algorithms**: I've implemented some
  more exotic data structures including Bloom Filters and Count Min Sketches. I
  understand the internals of most common data structures, and have solved a
  respectable number of UVa problems.

If your company is looking for a quick study and excellent coder get in touch.
If you know companies or people that have similar values reach out, I'd love to
talk to them.
