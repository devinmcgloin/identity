---
title: 'Qualities of Quality Software'
date: '2019-06-26'
tags:
  - Software
layout: 'post'
excerpt: What makes good software good? What attributes does it have, how can someone converge on better solutions?
---

What makes good software good? What attributes does it have, how can someone converge on better solutions?

### Why should we care?

Quality software for its own sake doesn’t make _any_ sense. It’s valuable for what it gets us. On first principles it’s useful as it makes the product a better experience, it’s easier to iterate on, build new features, and maintain. There’s a snowball effect here, the quicker you can iterate on product the better your product will become.

Why does that accumulate over time? First, you can experiment more easily with new features and ideas. Secondly, time to value is lower, meaning given the same amount of effort you’ll see more value in a system that is high quality vs one that is not. Perhaps most importantly given the same amount of investment it’s clear that developer productivity yields results for organizations, accounting for the increased market share / profits / resources that are realized from new features it’s easy to see how the investment snowballs.

### Attributes of Quality

1. Quality software is adaptive to change
2. Quality software has known properties that are easy to verify
3. Quality software can be understood locally (For any given change the working set of things that need to be considered is small.)
4. Quality software is the simplest solution that solves the problem with acceptable performance
5. Quality software is aware of the ways in which it can fail and attempts to reduce the impact of those failures
6. Quality software is observable by default
7. Quality software can be built up without having to change the foundations
8. Quality software is built in the most expedient manner that doesn’t sacrifice the above

### What sorts of organizations converge on quality as defined above?

- Ones that are rigorous / thoughtful about the approach.
- Leverage your peers to reduce ambiguity when you don’t have context and can’t derive it easily.
- Prefer high impact solutions that have global effects over small localized improvements.
- Push back on changes that are justified by saying the problem “goes away”
  - These are generally opportunities to understand the underlying systems
  - It’s important to know the why behind why the change works

Hopefully you find this framework useful, It gives me a fair amount of clarity so I hope it does for you too.
