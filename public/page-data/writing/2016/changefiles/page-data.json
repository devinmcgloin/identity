{"componentChunkName":"component---src-templates-writing-js","path":"/writing/2016/changefiles/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Changefiles\",\n  \"date\": \"2016-05-27\",\n  \"excerpt\": \"Changefiles are an interesting way to approach thinking about updating a piece of software. Allowing for more productive programmers and better libraries that can be tuned for a specific use case.\",\n  \"tags\": [\"Ideas\", \"Programming\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Peter Siebel has an excellent interview with Donald Knuth in his book \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.codersatwork.com/\"\n  }), \"Coders at\\nWork\"), \". Among other things they go into a bit of\\ndetail on the work Knuth did on literate programming with WEB and CWEB. The core\\nidea is that the program is written in a manner that explains itself to you with\\ndocumentation in a much more natural manner. While this is interesting, what I\\nfound a little more intriguing is the manner by which updates in CWEB or WEB\\nwere made.\"), mdx(\"p\", null, \"Essentially they were done through changefiles. Which is a list of deltas from\\nwhat ever version you're on to the latest version. If you apply all those\\nchanges then your code is up to date and synced with the latest release.\"), mdx(\"p\", null, \"Normally how updates are done is just wiping the old module and replacing it\\nwith the new one, then only time in which that isn't done is if you're working\\nwith a particularly large application and re downloading would be expensive.\"), mdx(\"p\", null, \"The beauty of a change file is not that it saves space alone, although that is\\none nice property. More importantly you can update a file and ignore changes\\nthat the user has made. This may seem like a somewhat particular use case, but I\\nthink it has some far flung consequences.\"), mdx(\"p\", null, \"Consider the situation in which you're working with a third party library. It\\nalmost does exactly what you need but there's a few things here or there that\\nyou wish you could change to made the code more specific to your problem.\\nPerhaps you need to specify a different comparator but you want to compare\\nacross types, or you want to apply some changes in the new release, but\\nintegrate other ones later.\"), mdx(\"p\", null, \"If individual changes were released as changefiles you could have all those\\nbenefits, and if you don't care about a specific release and want to apply the\\nnew version you can do that too.\"), mdx(\"p\", null, \"What I have in mind is a little more expansive than just forking a project and\\nmodifying code. More specifically you ought to be able to take any third party\\nfunction and modify arbitrary parts of the functions or class and have those\\nchanges apply in a specific scope. It could either be a change for a specific\\nfile, or for the whole project.\"), mdx(\"p\", null, \"One of the great things about this is that it would mean more cohesion among\\ndevelopers trying to solve the same problem. Instead of dividing their efforts\\nacross multiple projects that have subtle differences they could work on the\\nsame source and tweak what they needed to change.\"), mdx(\"h2\", null, \"Objections\"), mdx(\"p\", null, \"This of course will not change the differences between libraries that take a\\nfundamentally difference approach. You would not try to take a library that has\\nmade certain architectural choices in its core runtime. In part because that\\nwould require an excessive amount of work and any changes made the the original\\nwould probably not apply to the other. Similarly, there is an issue here in that\\nsome functions and files would rely upon other ones. What happens if you change\\none, and if you do, have you broken the whole system?\"), mdx(\"p\", null, \"In many ways the git model seems to do a decent job covering some of these use\\ncases. Individuals can make modifications and keep things in sync for the most\\npart. You can sync forks with other upstream branches and so on.\"), mdx(\"p\", null, \"I think the benefit here isn't so much being able to sync things, but rather\\nbeing free to modify with very little overhead. The result is a bunch of custom\\ntuned libraries that do a really good job with your use case. Installing these\\ncustom additions could also be done inline with other code, rather than having\\nto install from a dedicated repo. All in all, the git model does most of this\\nalready, and this probably isn't worth pursuing.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Changefiles","date":"Friday, May 27th 02016","tags":["Ideas","Programming"]},"excerpt":"Changefiles are an interesting way to approach thinking about updating a piece of software. Allowing for more productive programmers and better libraries that can be tuned for a specific use case."}},"pageContext":{"slug":"/writing/2016/changefiles/"}}}