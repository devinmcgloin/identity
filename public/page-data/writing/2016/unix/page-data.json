{"componentChunkName":"component---src-templates-writing-js","path":"/writing/2016/unix/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"What we can learn from Unix\",\n  \"date\": \"2016-05-28\",\n  \"excerpt\": \"The Unix Philosophy is a wonderfully cohesive way to thing about program execution and composition. Its beauty relies in its simplicity, somewhat unfortunately this is also tied to the fact that Unix is dealing with software on the operating system level. We’re going to explore what the Unix Philosophy is and what it allows us to do when working in a Unix shell. All the while exploring how Unix can guide our attempts to create simpler programs at a higher level of the stack.\",\n  \"tags\": [\"Software Design\", \"Programming\"],\n  \"layout\": \"post\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html\"\n  }), \"Unix Philosophy\"), \" is a wonderfully cohesive way to thing about program\\nexecution and composition. Its beauty relies in its simplicity, somewhat\\nunfortunately this is also tied to the fact that Unix is dealing with software\\non the operating system level. We're going to explore what the Unix Philosophy\\nis and what it allows us to do when working in a Unix shell. All the while\\nexploring how Unix can guide our attempts to create simpler programs at a higher\\nlevel of the stack.\"), mdx(\"h2\", null, \"What is the Unix Philosophy?\"), mdx(\"p\", null, \"The Unix Philosophy as described by Doug McIlroy - Inventor of the Unix pipe -\\nis the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Write programs that do one thing and do it well.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Write programs that work together.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Write programs that handle text streams, because its a universal interface.\")), mdx(\"p\", null, \"The core focus of unix is really simplicity. In part this is possible because\\nunix is focused on the operating system level and is therefore dealing with more\\nsimple representations, mainly text. As an operating system unix can make more\\nassumptions in regards to what protocols it can use and therefore exert more\\ncontrol over the content.\"), mdx(\"p\", null, \"What is perhaps more critical is that unix commands focused on manipulating text\\nstreams. All traditional unix commands work by taking some text as input from a\\nstream, and responding back with more text. For example if I run \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ls -l\"), \" in my\\nblog directory, I'll get back the following:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"404.html\\nCNAME\\nLICENSE\\nREADME.md\\n_config.yml\\n_data\\n_drafts\\n_ideas\\n_includes\\n_layouts\\n_pages\\n_posts\\n_projects\\n_refs\\n_sass\\n_site\\natom.xml\\ncss\\nfavicon.ico\\npublic\"))), mdx(\"p\", null, \"This is just text. Which means I can count the number of lines in it and know\\nhow many folders or files I have here, or I can replace some of the text etc.\\nThis means that any command can take the input of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"any\"), \" another command or be\\nthe output to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"any\"), \" other command. This is particularly powerful as any\\npossible composition can be made with these small building blocks. This is the\\nmost essential ingredient to making unix as useful as it is.\"), mdx(\"h2\", null, \"Benefits when working in the shell\"), mdx(\"p\", null, \"Commands like \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ls\"), \", \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rm\"), \" or \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"wc\"), \" do very simple tasks. For those who aren't\\nfamiliar \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ls\"), \" displays the files in your current directory, \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"rm\"), \" removes a file\\nat the specified path and \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"wc\"), \" counts characters, words and lines in a file. For\\nexample if you want to know how many files or folders you have in a directory\\nyou can run the following at the command prompt:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"$ ls | wc -l\"))), mdx(\"p\", null, \"Here \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ls\"), \" gives you a list of files line by line, and \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"wc -l\"), \" tells you the\\nnumber of lines in the output of \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"ls\"), \". The key idea here is that you can pipe\\nthe output of one program into the output of another. This is what it means to\\npipe one thing into another.\"), mdx(\"p\", null, \"If I want to do something more elaborate that can be done pretty easily as well.\\nSay I'm doing some writing and I want to know how many unique words I've used in\\na post.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"$ cat unix.md | tr -cs A-Za-z '\\\\n' | tr A-Z a-z | sort | uniq | wc -l\"))), mdx(\"p\", null, \"Another even more complicated example. Say you want to know which words in your\\npost you've used a lot of.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"$ cat unix.md | tr -cs A-Za-z '\\\\n' | tr A-Z a-z | sort | uniq -c | sort -rn | sed 10q\"))), mdx(\"p\", null, \"This will print out a listing of the 10 most common words and how often they've\\nbeen used in the file \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"unix.md\"), \". There is a bit of arcane knowledge here, but\\nthat isn't necessarily bad. The \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tr\"), \" command just replaces whats on the left\\nwith whats on the write. So \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"tr -cs A-Za-z '\\\\n'\"), \" is taking anything that is not\\na letter and replacing it with a new line.\"), mdx(\"p\", null, \"For comparison here is the equivalent Python script:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"python\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-python\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-python\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"from\"), \" collections \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"import\"), \" Counter\\ntext \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"\\\"\\\"\"), \"\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"with\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token builtin\"\n  }), \"open\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"\\\"unix.md\\\"\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"as\"), \" f\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \":\"), \"\\n    text \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" f\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"read\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \"\\n\\nc \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"=\"), \" Counter\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token builtin\"\n  }), \"map\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"lambda\"), \" s \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \":\"), \" s\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"lower\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token builtin\"\n  }), \"filter\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"lambda\"), \" s \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \":\"), \" s\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"isalpha\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" text\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"split\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token string\"\n  }), \"\\\" \\\"\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \"\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"for\"), \" word\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" num \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"in\"), \" c\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \".\"), \"most_common\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token number\"\n  }), \"10\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \":\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"print\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"num\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \",\"), \" word\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\")))), mdx(\"p\", null, \"It's worth noting that the python script will not count words that have a comma\\nafter them or some other punctuation. It would not count the word \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"wouldn't\"), \" as\\nit isn't strictly alphabetical. In order to could it you would have to bring\\nregex or the python string translate method into the mix, but it seemed like\\noverkill.\"), mdx(\"p\", null, \"I hope I've shown that using Unix commands can be incredibly useful in the right\\nscenarios. There's also a lot more than what I've covered here, including\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.grymoire.com/Unix/Awk.html\"\n  }), \"AWK\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.gnu.org/software/grep/manual/grep.html\"\n  }), \"grep\"), \".\"), mdx(\"h2\", null, \"Can we apply these concepts higher up the stack?\"), mdx(\"p\", null, \"If we know that unix principles are useful, and make building systems and\\nprograms easier, how can we apply those insights higher up the stack?\"), mdx(\"p\", null, \"If we write smaller functions that focus on a single task the quality of those\\nfunctions will go up, the overall quality of the library will increase, but the\\namount of work an individual will have to put in to learn that library will also\\nincrease. Furthermore, the library will probably not be as successful as\\nlibraries that give all in one magic methods for common tasks.\"), mdx(\"p\", null, \"Unix requires very active users, who are willing to learn and comb through man\\npages. Developers are of course willing to do this to an extent, but what they\\nreally want are magic boxes to solve their problems. Which if we're honest, who\\ncan blame them? The issue is that you end up relying on code that you don't\\nunderstand and therefore can't debug. This obviously isn't a good situation to\\nbe in, and is why full stack developers are sought after. Unix forces you to\\nlearn, which slows things down, harms adoption rates, but also produces better\\ndevelopers.\"), mdx(\"p\", null, \"Well we know that writing commands or functions that can be composed is useful,\\nand in order to compose them the functions themselves must generally be\\nstateless. That is if you run a command twice with the same parameters you ought\\nto get the same results. This is true for unix commands and that lesson is being\\napplied daily by functional programmers.\"), mdx(\"p\", null, \"One of the areas in which I think we need to spend more time on is a expansion\\nof text streams as the universal interface. I do think that text is incredibly\\nuseful, and very close to being a universal interface outside the unix\\necosystem. Where text streams fall short, at least where unix is concerned is\\nwhen you're working with data formats that are highly nested. For example JSON\\nor XML.\"), mdx(\"p\", null, \"As a result most developers spend the vast majority of their time dealing with\\nparsing data streams and working with text. Of course, the lack of support in\\nunix is not the only issue, but if we look at the manner by which unix modeled\\ntext streams they contain characters, which compose the entirely of the stream,\\nas well as special delimiter characters, such as \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"\\\\n\"), \" or \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"\\\\t\"), \". As a result\\ncommon operations focus on working with characters, lines or words, as defined\\nby the special delimiters or whitespace. There are good simple command line\\ntools like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stedolan.github.io/jq\"\n  }), \"jq\"), \" for working with JSON in the command line which aim to fix\\nthis issue. Essentially the issue boils down to mapping between two different\\nrepresentations, which is not a simple task for a machine to do automatically.\"), mdx(\"p\", null, \"There's a lot to be learned for unix, primarily to keep it simple, and keep it\\nfocused. The result is software that is easy to understand, and relatively\\nsimple to use.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"What we can learn from Unix","date":"Saturday, May 28th 02016","tags":["Software Design","Programming"]},"excerpt":"The Unix Philosophy is a wonderfully cohesive way to thing about program execution and composition. Its beauty relies in its simplicity, somewhat unfortunately this is also tied to the fact that Unix is dealing with software on the operating system level. We’re going to explore what the Unix Philosophy is and what it allows us to do when working in a Unix shell. All the while exploring how Unix can guide our attempts to create simpler programs at a higher level of the stack."}},"pageContext":{"slug":"/writing/2016/unix/"}}}