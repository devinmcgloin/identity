{"componentChunkName":"component---src-templates-writing-js","path":"/writing/2016/brooks-no-silver-bullet/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"layout\": \"paper\",\n  \"author\": \"Fred Brooks\",\n  \"category\": \"paper\",\n  \"date\": \"2016-02-14\",\n  \"title\": \"No Silver Bullet\",\n  \"source\": \"http://papers.devinmcgloin.com/worrydream/Brooks-NoSilverBullet.pdf\",\n  \"year\": 1986,\n  \"excerpt\": \"Programming, Brooks argues, can be separated into distinct tasks. The first is dealing with incidental complexity, and the second managing essential complexity. Brooks asks, How do we approach incedental complexity, and do those approaches have limits? What is the way forward to make the essential logic easier to manage?\",\n  \"tags\": [\"Management\", \"Software Engineering\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Fred_Brooks\"\n  }), \"Brooks\"), \" asserts that:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"There is no single development, in either technology or management technique,\\nwhich by itself promises even one order of-magnitude improvement within a\\ndecade in productivity, in reliability, in simplicity.\")), mdx(\"p\", null, \"Brooks is primarily concerned with programmer productivity, which is a critical\\ntopic as software is becoming far more complex and therefore the number of ways\\nin which it can fail is also increasing dramatically. We're far past the point\\nwhere a single person can understand the whole environment in which they work.\"), mdx(\"p\", null, \"Programming, Brooks argues, can be separated into distinct tasks. The first is\\ndealing with incidental complexity, and the second managing essential\\ncomplexity. We'd like to spend as much time as possible on the essential tasks,\\nthan on the incidental.\"), mdx(\"p\", null, \"Software projects will always be complex, as what makes software useful is it's\\ncomplexity. Brooks argues that:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The essence of a software entity is a construct of interlocking concepts, data\\nsets, relationships among data items, algorithms, and invocations of\\nfunctions. The essence is abstract ... but is nonetheless highly precise and\\nrichly detailed.\")), mdx(\"h2\", null, \"Does it have to be hard?\"), mdx(\"p\", null, \"The hard part about software is figuring out how these concepts relate, not the\\nactual act of programming. It's fundamentally about getting the relationships\\nbetween complex items right. This is what Brooks considers to be the essential\\nacts of programming.\"), mdx(\"p\", null, \"Brooks focuses on a few aspects that make programming especially difficult.\"), mdx(\"h3\", null, \"Complexity\"), mdx(\"p\", null, \"Brooks starts by asserting that software systems are far more complex than any\\nother human system. This is compounded by our inability to see their actions, or\\nunderstand the system visually. Common programming principles like\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Don't_repeat_yourself\"\n  }), \"DRY\"), \" focus on code reuse,\\nthis means that each item in a software system is unique.\"), mdx(\"p\", null, \"In a physical system, repetition of common parts is far more common, and\\ntherefore results in a system that is much easier to understand despite its high\\nnumber of moving parts. Take a car for example, say a car is composed of 100,000\\nparts. We can safely ignore 2/5 of those, due to repetition from the left side\\nand the right. Furthermore, common items like bolts, or bushings don't really\\nneed to be understood, so perhaps we can remove another 1/3. This brings our\\ntotal part count to around 40,000. And that is of course a rough estimation.\"), mdx(\"p\", null, \"Currently, my \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"usr\"), \" directory contains 18,843 directories, and 237,244 files.\\nThat isn't even the count of total functions that exist on my computer, which is\\nprobably at least 10 times the number of files, so around 2,372,440. That's a\\nwhole lot of functions, my guess is there are probably a bit more than that.\"), mdx(\"p\", null, \"If we go a step further an look at the total number of files on my computer to\\nallow it to \\\"do its thing\\\", you get a mind boggling number of files, 2,399,961\\nto be exact on my machine. Though this includes data files, so it's not really a\\nfair estimate, but you get the idea.\"), mdx(\"p\", null, \"Software is really complex, as things increase in complexity and also size, it\\nbecomes increasingly more difficult for people to understand the system, and\\ntalk about it with any authority. The possible state space for the system also\\nincreases dramatically. If a system have 500,000 possible states, you can't\\nreally prove all of them to be safe, much to the lament of\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD361.html\"\n  }), \"Dijkstra\"), \"\\nand\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://papers.devinmcgloin.com/worrydream/Lamport%20-%20The%20Future%20of%20Computing%20-%20Logic%20or%20Biology.pdf\"\n  }), \"Lamport\"), \".\\nBrooks wonders how we will combat complexity going forward.\"), mdx(\"h3\", null, \"Conformity\"), mdx(\"p\", null, \"Unlike physics software objects have no fundamental principles upon which they\\ncan rest. And therefore, each software artifact must be evaluated in isolation.\\nThis makes each evaluation many times more difficult, as you cannot treat any\\ntwo functions as truly equivalent until they have both been thoroughly\\ninvestigated. As you can imagine, this slows things down enormously.\"), mdx(\"h3\", null, \"Changeability\"), mdx(\"p\", null, \"The fact that software is adapted throughout its life time is another source of\\ncomplexity. Most physical products, argues Brooks, are not changed after\\nmanufacturing. Software, on the other hand, is guaranteed to require patches,\\nand updates on a somewhat regular basis. Software is also constantly being\\npushed towards the edge of its use case, as popular software is often used in\\ndomains it was not explicitly designed for. Thus, developers feel the desire to\\nsupport that additional functionality, and the software is no longer tailored\\ntowards a very specific use case.\"), mdx(\"p\", null, \"In some ways this is what's nice about the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.catb.org/esr/writings/taoup/html/ch01s06.html\"\n  }), \"Unix\\nPhilosophy\"), \".\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Programs should do one thing and do it well.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Expect the output of every program to become the input to another, as yet\\nunknown, program.\")), mdx(\"p\", null, \"This principles allow for small utilities to be pulled together through piping\\nthe output of one into the input of another.\"), mdx(\"h3\", null, \"Invisibility\"), mdx(\"p\", null, \"Software is also hard because we can't see it. We have to manipulate everything\\ninside our own heads, which leads to mistakes and conceptual errors. There is\\nalso no easy way to represent the content of a program in space. Object Oriented\\nLanguages can have \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Unified_Modeling_Language\"\n  }), \"UML\\nDiagrams\"), \" but these\\ndon't really solve the problem, as they're static and focus on class design, not\\nhow the program interacts dynamically. I've been working towards a better way to\\nvisualize outputs of functions called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/vtest\"\n  }), \"vtest\"), \", but visualizing programs\\nis a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hard\"), \" problem.\"), mdx(\"h2\", null, \"Past Gains\"), mdx(\"p\", null, \"Most gains have come from removing artificial barriers, and by their very nature\\nthese approaches limit themselves.\"), mdx(\"h3\", null, \"High Level Languages\"), mdx(\"p\", null, \"High level languages abstract away repeated patterns. Chances are you're going\\nto have to read in a file more than once, this operation is going to be very\\nvery similar each time you want to execute that procedure. In this case you\\nshould not have to rewrite a bespoke function to accomplish an essential\\nrepetitive task.\"), mdx(\"p\", null, \"Similarly the language allows the best version of each pattern to be used by\\neveryone without any additional cost. Most incidental complexity comes in the\\nform of rewriting the same patterns, and dealing with solved problems. This is a\\nhuge benefit, and increases productivity, according to Brooks estimation, by a\\nfactor of 5.\"), mdx(\"h3\", null, \"Time-Sharing\"), mdx(\"p\", null, \"Time-sharing is not appreciated as much as it was during its introduction in the\\nearly 1960s. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Multics\"\n  }), \"Multics\"), \" was the first of\\nsuch systems, and if you're not familiar with the concept\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\"\n  }), \"Computerphile\"), \" has an\\nexcellent video on the topic: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=-rPPqm44xLs\"\n  }), \"Mainframes and the Unix\\nRevolution\"), \".\"), mdx(\"p\", null, \"Time-Sharing essentially allows for multiple users to get back results from the\\nprograms in minutes rather than days. This delay time resulted in quicker\\niteration for programers, and therefore increased efficiency. Currently of\\ncourse, the response time is nearly immediate, and yet programming is still\\ndifficult. Brooks expands on time sharing, noting that as the time decreases the\\namount of benefit also decreases.\"), mdx(\"h3\", null, \"Unified programming environments\"), mdx(\"p\", null, \"Unified programming environments like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Unix\"\n  }), \"Unix\"), \"\\nand \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Interlisp\"\n  }), \"Interlisp\"), \", provided consistent\\nmetaphors and support for common tasks. This results in decreased computational\\noverhead for the programmer, and results in programs that can easily be\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#changeability\"\n  }), \"composed\"), \".\"), mdx(\"h2\", null, \"Future Steps\"), mdx(\"p\", null, \"Brooks contemplates future ways in which we can address common issues, and\\nconsiders if those solutions address incidental or essential complexity. I'm not\\ngoing to go into all these approaches, but if one piques your interest take a\\nlook at the full text.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  })), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  })), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  })))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"OOP\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Automatic Programming\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Environments and Tools\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"AI\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Graphical Programming\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Workstations\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Ada\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Expert Systems\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Program Verification\")))), mdx(\"h2\", null, \"Attacks on Essential Complexity\"), mdx(\"p\", null, \"Brooks believes that the conceptual aspects of programming are taking the\\nmajority of the time. Therefore, he focuses on methodologies to limit either the\\namount of time spent on a task, or how often it has to be accomplished.\"), mdx(\"h3\", null, \"Buy not Build\"), mdx(\"p\", null, \"Brooks notes that \\\"\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The most radical possible solution for constructing software\\nis to not construct it at all.\"), \"\\\" Therefore, when a simple off the shelf solution\\nexists, use it! Even if it's not done exactly the way you would like, its better\\nto use a well tested, proven solution the embarking to reinvent the wheel.\\nBrooks, I'm sure, would look at the\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Free_and_open-source_software\"\n  }), \"FOSS\"), \" solutions we\\nhave today and be delighted in the amount of code reuse.\"), mdx(\"p\", null, \"Brooks elaborates that most use cases are not significantly different from each\\nother, resulting in generic products that each user can integrate into their\\nworkflow. The key is keeping these products small and modular, which allows for\\nmuch easier composition.\"), mdx(\"h3\", null, \"Rapid prototyping\"), mdx(\"p\", null, \"One of the most difficult tasks when working on a software project is deciding\\nwhat exactly to build, and how the user interacts with it. It's much easier to\\nstart small in this case, and get feedback quickly.\"), mdx(\"p\", null, \"Rapid prototyping has also become more and more prevalent, as programmers and\\nDesigners have warmed up to the idea of showing people Minimum Viable Products,\\nthat the users can interact with. This gives excellent feedback to keep the\\nsoftware in light with the goals of the users.\"), mdx(\"h3\", null, \"Incremental Growing, not building.\"), mdx(\"p\", null, \"Brooks argues that software should be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"grown\"), \" organically.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"I still remember the jolt I felt in 1958 when I first heard a friend talk\\nabout \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"building\"), \" a program, as opposed to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"writing\"), \" one. In a flash he\\nbroadened my whole view of the software process.\")), mdx(\"p\", null, \"Brooks however thinks the building metaphor is not well equipped to handle the\\ncurrent projects we're developing. Instead of building, which requires adequate\\nplans and foresight, we should focus on growing a program organically. Once even\\na very simple program is up and running, developers are much more enthusiastic\\nabout the progress.\"), mdx(\"h3\", null, \"Great Designers\"), mdx(\"p\", null, \"In order to develop better systems, we must have better designers. It's not\\nsurprising that great designers produce software that is elegant, simple and\\ncohesive. Great designers have a vision regarding what computation should look\\nlike. Take this table from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"No Silver Bullet\"), \" showing languages that were\\ndesigned vs those done by committee.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Designer\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Committee\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Unix\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Cobol\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"APL\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"PL/1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Pascal\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Algol\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Lisp\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MVS/370\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Smalltalk\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MS-DOS\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": \"left\"\n  }), \"Fortran\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }))))), mdx(\"p\", null, \"Languages with great designers have a certain clarity to them, its something we\\nall should aim to have within our own programs.\"), mdx(\"p\", null, \"We ought to focus on making simple, elegant pieces of software that can compose\\neasily with other systems when we have to. If a solution exists, and it\\nsatisfies your need then use it!\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"No Silver Bullet","date":"Sunday, February 14th 02016","tags":["Management","Software Engineering"]},"excerpt":"Programming, Brooks argues, can be separated into distinct tasks. The first is dealing with incidental complexity, and the second managing essential complexity. Brooks asks, How do we approach incedental complexity, and do those approaches have limits? What is the way forward to make the essential logic easier to manage?"}},"pageContext":{"slug":"/writing/2016/brooks-no-silver-bullet/"}}}