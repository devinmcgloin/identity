{"componentChunkName":"component---src-templates-writing-js","path":"/writing/2016/types/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Universal Types\",\n  \"permalink\": \"/universal-types/\",\n  \"excerpt\": \"These types generally take the form of persistent trees. This allows people to modify them as they wish and recover from any unexpected changes. I have in mind that these objects will be stored in a collections framework that allows for common operations over most data structures\",\n  \"tags\": [\"Ideas\", \"Programming\"],\n  \"date\": \"2016-01-15\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"These types generally take the form of persistent trees. This allows people to\\nmodify them as they wish and recover from any unexpected changes. I have in mind\\nthat these objects will be stored in a collections framework that allows for\\ncommon operations over most data structures, called\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/projects/udb\"\n  }), \"UDB\"), \".\"), mdx(\"h2\", null, \"Building Blocks\"), mdx(\"p\", null, \"I think that every item can be composed of these core primitives. If you think\\notherwise send me an email with an example that breaks the system.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"text\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"locations\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"audio\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"video\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"messages\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"number\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"transactions\")), mdx(\"p\", null, \"This primitives along with an alias system allow for any type to be created.\"), mdx(\"h2\", null, \"Common Functions\"), mdx(\"p\", null, \"Because these types are consistent, and supported throughout the system, you can\\napply common filters, sorts, or apply functions to every item in the\\ncollection.\"), mdx(\"p\", null, \"For example, I would like to find a contact of mine, but I've forgotten their\\nname. I know I added them recently, and that they didn't give me their email. I\\nought to filter by contacts who do not have an email, then sort by how recently\\nI added them. I have about 600 contacts in my address book, and neither of these\\noperations would take much time, even if they are not heavily optimized.\"), mdx(\"p\", null, \"Imagine the power if you could do that for all these data types. You could find\\nthe closest \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \" just by getting a list of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \", then because they have a\\nlocation, you can find out their distance from your current location. The coffee\\nshop use case has been polished, and for coffee shops its super easy. What if\\nyou're looking on someones blog for good gluten free restaurants in Sacramento.\\nYou think this person knows what they're talking about, and you'd like to know\\nhow far away all of them are.\"), mdx(\"p\", null, \"Well, right now you have to type them all in to google maps, or have knowledge\\nof the area to figure out how far away they are. This is obviously sub optimal.\\nIf you have a list of restaurants, even just their names and a general\\ngeographical location, you ought to be able to find the distance from you to\\nthem without having to code something to do it, or type in 10 address to google,\\nand compare across multiple tabs.\"), mdx(\"p\", null, \"This is basically an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Entity_component_system\"\n  }), \"Entity Component\\nModel\"), \" applied to general\\nprogramming.\"), mdx(\"h2\", null, \"Items\"), mdx(\"p\", null, \"Each item has an identifier and a series of \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"key:val\"), \" pairs. Each of these keys\\nindicates that the item has a attribute of that type. If the item has multiple\\nvalues of the same type then they just form an array under the specified key.\\n\", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"key:[val1, val2]\")), mdx(\"h3\", null, \"Representing Items\"), mdx(\"p\", null, \"Suppose you have a news article:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"article1209{\\n  author: Devin McGloin\\n  title: Universal Types\\n  date: 2016-01-29\\n  text: These types generally take the form of persistent trees...\\n  source: http://blog.devinmcgloin.com/universal-types\\n}\"))), mdx(\"p\", null, \"All articles are based off this template:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"article{\\n  author:\\n  title:\\n  date:\\n  text:\\n  source:\\n}\"))), mdx(\"p\", null, \"Some of these are not in list of primitives above. \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"author\"), \" is an alias for\\n\", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"person\"), \". An author looks like this:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"author{\\n  alias: person\\n}\\nperson{\\n  first-name:\\n  middle-name:\\n  last-name:\\n  email:\\n  phoneNumber:\\n  address:\\n  employer:\\n  hometown:\\n}\"))), mdx(\"h3\", null, \"Interfaces\"), mdx(\"p\", null, \"We need a mechanism to ensure that each alias is what it says it is. This is\\nonly an issue for aliased types, and not compositions. If the alias is not a\\nsubset it does not need to be verified, as all members of text can be aliased as\\nstrings. However, a url would be aliased from text, but is actually a subset of\\ntext.\"), mdx(\"p\", null, \"For text the answer is somewhat simple, have regex matching patterns that\\nconfirm the identity of the alias.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"url{\\n  alias: text\\n  matches: #\\\\b(([\\\\w-]+://?|www[.])[^\\\\s()<>]+(?:\\\\([\\\\w\\\\d]+\\\\)|([^[:punct:]\\\\s]|/)))#iS\\n}\"))), mdx(\"p\", null, \"I don't see a use case for aliasing \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"location\"), \" for example, to a smaller subset\\nthat doesn't result in a new composite type. If you do, please get in touch!\"), mdx(\"h3\", null, \"Algebraic Types\"), mdx(\"p\", null, \"The \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"source\"), \" item in the article template is a rather vague term, in fact this\\nis intentional, as we would like to define a generic article, rather than have a\\nweb-article with a url, and a journal-article with a journal edition. We'd like\\nto treat those two things as part of the same greater idea.\"), mdx(\"p\", null, \"A good solution to this problem is introducing algebraic datatypes. Composition\\nalready covers the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"and\"), \" use case, so what we're really look for is \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"either\"), \".\\nThe source is either a url, isbn or a journal. Either does not allow for both a\\nurl and an ISBN.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"source{\\n  either: [url, isbn, journal]\\n}\"))), mdx(\"h2\", null, \"More to do\"), mdx(\"p\", null, \"Obviously, there is a lot more do do around these ideas. If you find them\\ninteresting I'd love to talk with you!\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Universal Types","date":"Friday, January 15th 02016","tags":["Ideas","Programming"]},"excerpt":"These types generally take the form of persistent trees. This allows people to modify them as they wish and recover from any unexpected changes. I have in mind that these objects will be stored in a collections framework that allows for common operations over most data structures"}},"pageContext":{"slug":"/writing/2016/types/"}}}