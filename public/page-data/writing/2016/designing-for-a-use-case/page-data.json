{"componentChunkName":"component---src-templates-writing-js","path":"/writing/2016/designing-for-a-use-case/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Designing for a use case\",\n  \"date\": \"2016-01-29\",\n  \"tags\": [\"Software Design\", \"Programming\"],\n  \"layout\": \"post\",\n  \"excerpt\": \"When you develop an application or some software artifact you consider what task the program is to complete. You make a model of who your customers are, and how they interact with your service, and then you proceed to implement that.\\n\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you develop an application or some software artifact you consider what task\\nthe program is to complete. You make a model of who your customers are, and how\\nthey interact with your service, and then you proceed to implement that.\\nUnfortunately you cannot predict every possible use case for your program, you\\nend up choosing a few prime use cases and focusing on those. This makes them\\neasy to discover and use, which is great. But what if those aren\\u2019t the\\noperations your users really want?\"), mdx(\"p\", null, \"I would argue that these compromises make it very difficult for your customers\\nto complete complex tasks, and also alienates the user if their task is one of\\nthe marginalized ones. They could imagine that their task is so insignificant\\nthat nobody would bother to produce a system that could do it. But this really\\ndoes not have to be this way, we could instead give the users power over what\\nthey do with their data. We need to expose the functions people want in a\\nlogical consistent manner, and then let them interact with those items however\\nthey wish.\"), mdx(\"p\", null, \"This requires logical consistency throughout the system. An operation on one\\nitem should have the same effect as on all other items that are logically\\nequivalent. Users must not worry about their data-structures, and those\\ndata-structures ought to be dynamically optimized to account for the users usage\\npattern.\"), mdx(\"h2\", null, \"Common operations across collections\"), mdx(\"p\", null, \"Anyone ought to be able to apply bulk operations over any collection, but right\\nnow the only collections that really support this are music, emails, and perhaps\\ntransactions. I ran across this problem trying to remove old iPhone apps from my\\niCloud list. Apple lets you remove them, but only one at a time. There is no way\\nto select more than one item, and remove all of those selected items from the\\nlist. There's no doubt that it is technically possible for this to be a feature,\\nbut Apple doesn't care if you can do it easily. Easy should be the default, and\\nadopting a universal way to deal with data is part of the solution to this\\nproblem.\"), mdx(\"p\", null, \"The issue is that developers don\\u2019t think its important for their application to\\nsupport those operations. Users as a result think they don\\u2019t need them, and\\nthey\\u2019re not relevant to what they want to accomplish. The result is a severely\\nsuboptimal environment for those using our products.\"), mdx(\"p\", null, \"I think the solution is to expose the programming to the user, not thru a\\nterminal, but thru a GUI. The operations have to make intuitive sense for any\\nreasonable person. Data structures will have to be persistent and invisible to\\nthe user. This is why I\\u2019m currently working on\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/devinmcgloin/udb\"\n  }), \"UDB\"), \", a collection framework that\\ndynamically optimizes data structures given the most common access operations.\\nThis flies directly in the face of optimization and performance, however this is\\nnot a huge issue as collections are generally small, and programmers can\\noptimize for certain use cases, eg photo applications, or email, to provide\\nbetter performance. They key thing though, is that all operations have to be\\nsupported by all underlying data structures. This gives people a consistent\\nframe of mind, without it the system becomes to complex for normal people to\\ngrasp.\"), mdx(\"h2\", null, \"Common operations across logical datatypes\"), mdx(\"p\", null, \"Another issue is that the same types of data are represented in different ways,\\nwithout letting a universal set of operations that apply to data of the same\\nlogical type. This is another issue where the user does not understand why it\\nneeds to be this way, and it really doesn't. The key to fixing this issue is\\nproviding a large library of operations that work for logical primitives.\\nDevelopers can specify a single method to translate their current data format\\ninto the format that the user prefers. Some examples of logical primitives would\\nbe \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"times\"), \", \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"locations\"), \" or various forms of media. There are quite a few other\\nprimitives, you can find a full list \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/universal-types\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Because these types are consistent, and supported throughout the system, you can\\napply common filters, sorts, or apply functions to every item in the collection.\"), mdx(\"p\", null, \"For example, I would like to find a contact of mine, but I've forgotten their\\nname. I know I added them recently, and that they didn't give me their email. I\\nought to filter by contacts who do not have an email, then sort by how recently\\nI added them. I have about 600 contacts in my address book, and neither of these\\noperations would take much time, even if they are not heavily optimized.\"), mdx(\"p\", null, \"Imagine the power if you could do that for all these data types. You could find\\nthe closest \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \" just by getting a list \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \" then because they have a location,\\nyou can find out their distance from your current location. The coffee shop use\\ncase has been polished, and for coffee shops its super easy. What if you're\\nlooking on someones blog for good gluten free restaurants in Sacramento. You\\nthink this person knows what they're talking about, and you'd like to know how\\nfar away all of them are. Well, right now you have to type them all in to Google\\nmaps, or have knowledge of the area to figure out how far away they are. This is\\nobviously sub optimal. If you have a list of restaurants, even just their names\\nand a general geographical location, you ought to be able to find the distance\\nfrom you to them without having to code something to do it, or type in 10\\naddress to Google, and compare across multiple tabs.\"), mdx(\"h2\", null, \"Programmers provide the data, and the user manipulates it\"), mdx(\"p\", null, \"One of the huge benefits of such a system is that developers can focus on the\\napplications that are critical to what they do. That is their business logic, or\\nleveraging their unique dataset. They don't have to develop an app, they don't\\nhave to really bother with data conversion, and they don't have to focus on the\\nclient side. Furthermore any added function to a primitive will immediately\\npropagate throughout the entire system. This means that code really only has to\\nbe written once, and each developer doesn't have to spend time solving problems\\nthat have already been solved.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Designing for a use case","date":"Friday, January 29th 02016","tags":["Software Design","Programming"]},"excerpt":"When you develop an application or some software artifact you consider what task the program is to complete. You make a model of who your customers are, and how they interact with your service, and then you proceed to implement that.\n"}},"pageContext":{"slug":"/writing/2016/designing-for-a-use-case/"}}}